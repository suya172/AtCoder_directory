{
	"Print to console": {
	"prefix": "tmp",
	"body": [
        "#include <bits/stdc++.h>",
        "#include <sys/time.h>",
        "",
        "using namespace std;",
        "",
        "#ifdef ATCODER",
        "#include <atcoder/all>",
        "using namespace atcoder;",
        "template <int m>",
        "ostream &operator<<(ostream &os, const atcoder::static_modint<m> &a) { os << a.val(); return os; }",
        "#else",
        "#endif",
        "",
        "#pragma GCC target(\"avx\")",
        "#pragma GCC optimize(\"O3\")",
        "#pragma GCC optimize(\"unroll-loops\")",
        "",
        "using ull = unsigned long long;",
        "using ll = long long;",
        "using ld = long double;",
        "const ld EPS=1e-14;",
        "const int INF = 1001001001; // 1e+9",
        "const ll LINF = 1001001001001001001; // 1e+18",
        "// pair",
        "using pii = pair<int, int>;",
        "using pll = pair<ll,ll>;",
        "// vector",
        "using vi = vector<int>;",
        "using vvi = vector<vi>;",
        "using vvvi = vector<vvi>;",
        "using vl = vector<long>;",
        "using vvl = vector<vl>;",
        "using vll = vector<ll>;",
        "using vvll = vector<vll>;",
        "using vvvll = vector<vvll>;",
        "using vs = vector<string>;",
        "using vpii = vector<pii>;",
        "using vpll = vector<pll>;",
        "using vb = vector<bool>;",
        "using vvb = vector<vb>;",
        "// unordered set",
        "using usi = unordered_set<int>;",
        "using usll = unordered_set<ll>;",
        "using uss = unordered_set<string>;",
        "",
        "#define pb push_back",
        "#define mp make_pair",
        "#define um unordered_map",
        "#define YESNO(bool) if(bool){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}",
        "#define yesno(bool) if(bool){cout<<\"yes\"<<endl;}else{cout<<\"no\"<<endl;}",
        "#define YesNo(bool) if(bool){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}",
        "#define all(v) v.begin(),v.end()",
        "#define rall(v) v.rbegin(),v.rend()",
        "#define SUM(v) accumulate(all(v),0LL) ",
        "#define MIN(v) *min_element(all(v))",
        "#define MAX(v) *max_element(all(v))",
        "#define SORT(v) sort(all(v));",
        "#define REV(v) reverse(all(v));",
        "#define SIZ(v) int(v.size());",
        "#define pf push_front",
        "#define pb push_back",
        "#define ef emplace_front",
        "#define eb emplace_back",
        "#define ppf pop_front",
        "#define ppb pop_back",
        "#ifdef __LOCAL",
        "#define debug(...) { cout << #__VA_ARGS__; cout << \": \"; print(__VA_ARGS__); cout << flush; }",
        "#else",
        "#define debug(...) void(0);",
        "#endif",
        "#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );",
        "#define itn int",
        "#define stirng string",
        "#define pritn print",
        "",
        "// キーボードの1~4キーが壊れた",
        "#define one 1",
        "#define two 2",
        "#define three 3",
        "#define four 4",
        "",
        "/* REP macro */",
        "#define reps(i, a, n) for (ll i = (a); i < (ll)(n); ++i)",
        "#define rep(i, n) reps(i, 0, n)",
        "#define rrep(i, n) reps(i, 1, n + 1)",
        "#define repd(i,n) for(ll i=n-1;i>=0;i--)",
        "#define rrepd(i,n) for(ll i=n;i>=1;i--)",
        "#define repv(i,v) for(const auto& i:v)",
        "",
        "/* func */",
        "inline int ctoi(char c) {return c - '0';}",
        "template <typename T> inline int lb_itr(vector<T> v,T a){return lower_bound(all(v),a)-v.begin();}",
        "template <typename T> inline int ub_itr(vector<T> v,T a){return upper_bound(all(v),a)-v.begin();}",
        "",
        "// 第一引数と第二引数を比較し、第一引数(a)をより大きい/小さい値に上書き",
        "template <typename T> inline bool chmin(T& a, const T& b) {bool compare = a > b; if (a > b) a = b; return compare;}",
        "template <typename T> inline bool chmax(T& a, const T& b) {bool compare = a < b; if (a < b) a = b; return compare;}",
        "",
        "void Main();",
        "int main() {std::cin.tie(nullptr);std::ios_base::sync_with_stdio(false);std::cout << std::fixed << std::setprecision(15);Main();return 0;}",
        "",
        "//標準入出力",
        "template <typename T1, typename T2>",
        "ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }",
        "template <typename T1, typename T2>",
        "istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }",
        "template <typename T>",
        "ostream &operator<<(ostream &os, const vector<T> &v) { for (int i = 0; i < (int)v.size(); i++) { os << v[i] << (i + 1 != (int)v.size() ? \" \": \"\");}return os;}",
        "template <typename T>",
        "ostream &operator<<(ostream &os, const vector<vector<T>> &v) { for (int i = 0; i < (int)v.size(); i++) { os << v[i] << endl;} return os;}",
        "template <typename T>",
        "ostream &operator<<(ostream &os, const vector<vector<vector<T>>> &v) { for (int i = 0; i < (int)v.size(); i++) { os << \"i = \" << i << endl; os << v[i];}return os;}",
        "template <typename T>",
        "istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }",
        "template <typename T, typename S>",
        "ostream &operator<<(ostream &os, const map<T, S> &mp) { for (auto &[key, val] : mp) { os << key << \":\" << val << \" \";} return os;}",
        "template <typename T>",
        "ostream &operator<<(ostream &os, const set<T> &st) { auto itr = st.begin(); for (int i = 0; i < (int)st.size(); i++) {os << *itr << (i + 1 != (int)st.size() ? \" \": \"\");itr++;}return os;}",
        "template <typename T>",
        "ostream &operator<<(ostream &os, const multiset<T> &st){ auto itr = st.begin(); for (int i = 0; i < (int)st.size(); i++) { os << *itr << (i + 1 != (int)st.size() ? \" \": \"\");itr++;}return os;}",
        "template <typename T>",
        "ostream &operator<<(ostream &os, queue<T> q){ while (q.size()) { os << q.front() << \" \";q.pop(); }return os;}",
        "template <typename T>",
        "ostream &operator<<(ostream &os, deque<T> q) { while (q.size()) { os << q.front() << \" \"; q.pop_front();} return os;}",
        "template <typename T>",
        "ostream &operator<<(ostream &os, stack<T> st) { while (st.size()){ os << st.top() << \" \"; st.pop();} return os;}",
        "template <class T, class Container, class Compare>",
        "ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> pq) { while (pq.size()) {os << pq.top() << \" \";pq.pop();}return os;}",
        "template <typename T> inline void print(const T& a){cout << a << '\\n';return;}",
        "#define priturn(i) {print(i);return;}",
        "/*",
        "OK、ACゲット。",
        "                  ∧＿∧",
        "       ∧＿∧   （´<_`   ）  流石だよな俺ら。",
        "      （  ´_ゝ`）  /     ⌒i",
        "     ／      ＼         |  |",
        "____/       /￣￣￣￣/  |",
        "___(__ﾆつ/   FMV   / .| .|________",
        "       ＼/_______/  （u  ⊃",
        "           ｶﾞｶﾞｶﾞｶﾞ・・・・",
        "--------------------------------------------------------",
        "*/",
        "void Main () {",
        "   ",
        "}",
	],
	"description": ""
	},
	"inputvec": {
		"body": [
			"vector<${1:int}> ${2:vec}(${3:N});",
			"rep(i,$3) cin >> $2[i];",
			""
		],
		"description": "inputvec",
		"prefix": "ivec"
	},
	"inputint": {
		"body": [
			"int ${1:N}; cin>>$1;"
		],
		"description": "inputint",
		"prefix": "iint"
	},
	"inputtwoint": {
		"body": [
			"int ${1:N},${2:M}; cin>>$1>>$2;"
		],
		"description": "inputtwoint",
		"prefix": "iints"
	},
	"inputstring": {
		"body": [
			"string ${1:S}; cin>>$1;"
		],
		"description": "inputstring",
		"prefix": "istr"
	},
	"inputchar": {
		"body": [
			"char ${1:c}; cin>>$1;"
		],
		"description": "inputchar",
		"prefix": "ichar"
	},
	"inputll": {
		"body": [
			"ll ${1:N}; cin>>$1;"
		],
		"description": "inputll",
		"prefix": "ill"
	},
	"inputtwoll": {
		"body": [
			"ll ${1:N},${2:M}; cin>>$1>>$2;"
		],
		"description": "inputtwoll",
		"prefix": "ills"
	},
	"inputdouble": {
		"body": [
			"double ${1:D}; cin>>$1;"
		],
		"description": "inputdouble",
		"prefix": "idouble"
	},
	"inputtwodouble": {
		"body": [
			"double ${1:D},${2:E}; cin>>$1>>$2;"
		],
		"description": "inputtwodouble",
		"prefix": "idoubles"
	},
    "iugraph": {
        "prefix": "iugraph",
        "body": [
            "vvll G(${1:N});",
            "rep(i,${2:M}){",
            "   ll a,b; cin>>a>>b;",
            "   a--;",
            "   b--;",
            "   G[a].pb(b);",
            "   G[b].pb(a);",
            "}",
        ],
        "description": "input undirected graph"
    },
    "idgraph": {
        "prefix": "idgraph",
        "body": [
            "vvll G(${1:N});",
            "rep(i,${2:M}){",
            "   ll a,b; cin>>a>>b;",
            "   a--;",
            "   b--;",
            "   G[a].pb(b);",
            "}",
        ],
        "description": "input directed graph"
    },
	"meguru_binary_search": {
		"body": [
			"// めぐる式二分探索",
			"// (ng, ok] or [ok, ng)",
			"// 条件を満たす最小(最大)のindex okと",
			"// 条件を満たさない最大(最小)のindex ngを探索する",
			"ll ok = ${1:n};  // 条件を満たすindex",
			"ll ng = ${2:-1};   // 条件を満たさないindex",
			"while (abs(ok - ng) > 1) {",
			"    ll mid = (ok + ng) / 2;",
			"    if (${3:isSatisfy}(mid))",
			"        ok = mid;",
			"    else",
			"        ng = mid;",
			"}",
			""
		],
		"description": "meguru_binary_search",
		"prefix": "meguru_binary_search"
	},
	"uf": {
		"prefix": "UF",
		"body": [
			"class UnionFind{",
            "public:",
            "    vector<ll> parent; //parent[i]はiの親",
            "    vector<ll> siz; //素集合のサイズを表す配列(1で初期化)",
            "    map<ll,vector<ll>> group; //集合ごとに管理する(key:集合の代表元、value:集合の要素の配列)",
            "    ll n; //要素数",
            "",
            "    //コンストラクタ",
            "    UnionFind(ll n_):n(n_),parent(n_),siz(n_,1){ ",
            "        //全ての要素の根が自身であるとして初期化",
            "        for(ll i=0;i<n;i++){parent[i]=i;}",
            "    }",
            "",
            "    //データxの属する木の根を取得(経路圧縮も行う)",
            "    ll root(ll x){",
            "        if(parent[x]==x) return x;",
            "        return parent[x]=root(parent[x]);//代入式の値は代入した変数の値なので、経路圧縮できる",
            "    }",
            "",
            "    //xとyの木を併合",
            "    bool merge(ll x,ll y){",
            "        ll rx=root(x);//xの根",
            "        ll ry=root(y);//yの根",
            "        if(rx==ry) return false;//同じ木にある時",
            "        //小さい集合を大きい集合へと併合(ry→rxへ併合)",
            "        if(siz[rx]<siz[ry]) swap(rx,ry);",
            "        siz[rx]+=siz[ry];",
            "        parent[ry]=rx;//xとyが同じ木にない時はyの根ryをxの根rxにつける",
            "        return true;",
            "    }",
            "",
            "    //xとyが属する木が同じかを判定",
            "    bool same(ll x,ll y){",
            "        ll rx=root(x);",
            "        ll ry=root(y);",
            "        return rx==ry;",
            "    }",
            "",
            "    //xの素集合のサイズを取得",
            "    ll size(ll x){",
            "        return siz[root(x)];",
            "    }",
            "",
            "    //素集合をそれぞれグループ化",
            "    void grouping(){",
            "        //経路圧縮を先に行う",
            "        rep(i,n)root(i);",
            "        //mapで管理する(デフォルト構築を利用)",
            "        rep(i,n)group[parent[i]].pb(i);",
            "    }",
            "",
            "    //素集合系を削除して初期化",
            "    void clear(){",
            "        rep(i,n){parent[i]=i;}",
            "        siz=vector<ll>(n,1);",
            "        group.clear();",
            "    }",
            "};",
			""
		],
		"description": "UnionFind木"
	},
    "segtree_template": {
        "prefix": "segtree_template",
        "body": [
            "//モノイドの型 : ${1:ll}",
            "//op ：モノイドの作用",
            "//e ：モノイドの単位元",
            "$1 op($1 a, $1 b) {",
            "    return ${2:min(a, b)};",
            "}",
            "",
            "$1 e() {",
            "    return ${3:LINF};",
            "}",
        ],
        "description": "ACLのsegmenttreeを使うための下準備"
    },
    "lazysegtree_template": {
        "prefix": "lazysegtree_template",
        "body": [
            "//モノイドの型 : ${1:ll}",
            "//写像の型 : ${2:ll}",
            "//op ：モノイドの作用",
            "//e ：モノイドの単位元",
            "//mapping ：一点変更用の作用",
            "//composition ：遅延評価(範囲変更)用の作用",
            "//id ：作用 composition の単位元",
            "$1 op(ll a, ll b) {",
            "    return ${3:min(a, b)};",
            "}",
            "",
            "$1 e() {",
            "    return ${4:LINF};",
            "}",
            "",
            "$2 mapping(ll f, ll x) {",
            "    return ${5:x + f};",
            "}",
            "",
            "$2 composition(ll f, ll g) {",
            "    return ${6:f + g};",
            "}",
            "",
            "$2 id() {",
            "    return ${7:0};",
            "}",
        ],
        "description": "ACLでlazysegtreeを使うための下準備"
    },

	"iscross": {
		"prefix": "iscross",
		"body": [
			"bool iscross(pair<int,int>p1,pair<int,int>p2,pair<int,int>p3,pair<int,int>p4){",
			"  ll t1,t2,t3,t4;",
			"  t1 = f(p1, p2, p3);",
			"  t2 = f(p1, p2, p4);",
			"  t3 = f(p3, p4, p1);",
			"  t4 = f(p3, p4, p2);",
			"  return t1*t2 < 0.0 && t3*t4 < 0.0;",
			"}"
		],
		"description": "二点を結ぶ線分同士が交わるかどうか"
	},
	"nck": {
		"prefix": "nck",
		"body": [
			"ll nCk(int n, int k) {",
			"    ll x = 1; // n!の初期値",
			"    ll y = 1; // (n-k)!の初期値",
			"    ll z = 1; // k!の初期値",
			"",
			"    // 演算ごとにMODをとる",
			"    rep(i, n) x = (x * (n - i)) % MOD; // n!を計算",
			"    rep(i, n - k) y = (y * (n - k - i)) % MOD; // (n-k)!を計算",
			"    rep(i, k) z = (z * (k - i)) % MOD; // k!を計算",
			"",
			"    // 先に分母をMODの世界で計算してあげる",
			"    ll yz = (y * z) % MOD;",
			"",
			"    // 定義通りに計算",
			"    return (x / (yz)) % MOD;",
			"}",
			""
		],
		"description": "重複なし組み合わせ"
	},
	"Priority_Sum": {
		"prefix": "Priority_Sum",
		"body": [
			"template< typename T, typename Compare = less< T >, typename RCompare = greater< T > >",
			"struct PrioritySumStructure {",
			"",
			"  size_t k;",
			"  T sum;",
			"",
			"  priority_queue< T, vector< T >, Compare > in, d_in;",
			"  priority_queue< T, vector< T >, RCompare > out, d_out;",
			"",
			"  PrioritySumStructure(int k) : k(k), sum(0) {}",
			"",
			"  void modify() {",
			"    while(in.size() - d_in.size() < k && !out.empty()) {",
			"      auto p = out.top();",
			"      out.pop();",
			"      if(!d_out.empty() && p == d_out.top()) {",
			"        d_out.pop();",
			"      } else {",
			"        sum += p;",
			"        in.emplace(p);",
			"      }",
			"    }",
			"    while(in.size() - d_in.size() > k) {",
			"      auto p = in.top();",
			"      in.pop();",
			"      if(!d_in.empty() && p == d_in.top()) {",
			"        d_in.pop();",
			"      } else {",
			"        sum -= p;",
			"        out.emplace(p);",
			"      }",
			"    }",
			"    while(!d_in.empty() && in.top() == d_in.top()) {",
			"      in.pop();",
			"      d_in.pop();",
			"    }",
			"  }",
			"",
			"  T query() const {",
			"    return sum;",
			"  }",
			"",
			"  void insert(T x) {",
			"    in.emplace(x);",
			"    sum += x;",
			"    modify();",
			"  }",
			"",
			"  void erase(T x) {",
			"    assert(size());",
			"    if(!in.empty() && in.top() == x) {",
			"      sum -= x;",
			"      in.pop();",
			"    } else if(!in.empty() && RCompare()(in.top(), x)) {",
			"      sum -= x;",
			"      d_in.emplace(x);",
			"    } else {",
			"      d_out.emplace(x);",
			"    }",
			"    modify();",
			"  }",
			"",
			"  void set_k(size_t kk) {",
			"    k = kk;",
			"    modify();",
			"  }",
			"",
			"  size_t get_k() const {",
			"    return k;",
			"  }",
			"",
			"  size_t size() const {",
			"    return in.size() + out.size() - d_in.size() - d_out.size();",
			"  }",
			"};",
			"",
			"template< typename T >",
			"using MaximumSum = PrioritySumStructure< T, greater< T >, less< T > >;",
			"",
			"template< typename T >",
			"using MinimumSum = PrioritySumStructure< T, less< T >, greater< T > >;",
			""
		],
		"description": "スライド区間内の小さい・大きい順にK個の和"
	},
	"isPrime": {
		"prefix": "isPrime",
		"body": [
			"bool IsPrime(int num)",
			"{",
			"    if (num < 2) return false;",
			"    else if (num == 2) return true;",
			"    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く",
			"",
			"    double sqrtNum = sqrt(num);",
			"    for (int i = 3; i <= sqrtNum; i += 2)",
			"    {",
			"        if (num % i == 0)",
			"        {",
			"            // 素数ではない",
			"            return false;",
			"        }",
			"    }",
			"",
			"    // 素数である",
			"    return true;",
			"}"
		],
		"description": "素数判定"
	},
	"powmod": {
		"prefix": "powmod",
		"body": [
			"ll powmod(ll x,ll y){",
			"    ll res=1;",
			"    for(ll i=0;i<y;i++){",
			"      res=res*x%MOD;",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"tmpy": {
        "prefix": "tmpy",
        "body": [
            "#include<bits/stdc++.h>",
            "#include<ext/pb_ds/assoc_container.hpp>",
            "#include<ext/pb_ds/tree_policy.hpp>",
            "#include<ext/pb_ds/tag_and_trait.hpp>",
            "#define overload4(_1, _2, _3, _4, name, ...) name",
            "#define rep1(i, n) for (ll i = 0; i < ll(n); ++i)",
            "#define rep2(i, s, n) for (ll i = ll(s); i < ll(n); ++i)",
            "#define rep3(i, s, n, d) for(ll i = ll(s); i < ll(n); i+=d)",
            "#define rep(...) overload4(__VA_ARGS__,rep3,rep2,rep1)(__VA_ARGS__)",
            "#define rrep1(i, n) for (ll i = ll(n)-1; i >= 0; i--)",
            "#define rrep2(i, n, t) for (ll i = ll(n)-1; i >= (ll)t; i--)",
            "#define rrep3(i, n, t, d) for (ll i = ll(n)-1; i >= (ll)t; i-=d)",
            "#define rrep(...) overload4(__VA_ARGS__,rrep3,rrep2,rrep1)(__VA_ARGS__)",
            "#define all(a) a.begin(),a.end()",
            "#define rall(a) a.rbegin(),a.rend()",
            "#define SUM(a) accumulate(all(a),0LL)",
            "#define MIN(a) *min_element(all(a))",
            "#define MAX(a) *max_element(all(a))",
            "#define SORT(a) sort(all(a));",
            "#define REV(a) reverse(all(a));",
            "#define SZ(a) int(a.size())",
            "#define popcount(x) __builtin_popcountll(x)",
            "#define pf push_front",
            "#define pb push_back",
            "#define ef emplace_front",
            "#define eb emplace_back",
            "#define ppf pop_front",
            "#define ppb pop_back",
            "#ifdef __LOCAL",
            "#define debug(...) { cout << #__VA_ARGS__; cout << \": \"; print(__VA_ARGS__); cout << flush; }",
            "#else",
            "#define debug(...) void(0);",
            "#endif",
            "#define INT(...) int __VA_ARGS__;scan(__VA_ARGS__)",
            "#define LL(...) ll __VA_ARGS__;scan(__VA_ARGS__)",
            "#define STR(...) string __VA_ARGS__;scan(__VA_ARGS__)",
            "#define CHR(...) char __VA_ARGS__;scan(__VA_ARGS__)",
            "#define DBL(...) double __VA_ARGS__;scan(__VA_ARGS__)",
            "#define LD(...) ld __VA_ARGS__;scan(__VA_ARGS__)",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "using ll = long long;",
            "using ld = long double;",
            "using P = pair<int, int>;",
            "using LP = pair<ll, ll>;",
            "using vi = vector<int>;",
            "using vvi = vector<vi>;",
            "using vvvi = vector<vvi>;",
            "using vl = vector<ll>;",
            "using vvl = vector<vl>;",
            "using vvvl = vector<vvl>;",
            "using vd = vector<double>;",
            "using vvd = vector<vd>;",
            "using vs = vector<string>;",
            "using vc = vector<char>;",
            "using vvc = vector<vc>;",
            "using vb = vector<bool>;",
            "using vvb = vector<vb>;",
            "using vp = vector<P>;",
            "using vvp = vector<vp>;",
            "using vlp = vector<LP>;",
            "using vvlp = vector<vlp>;",
            "template<class T>",
            "using PQ = priority_queue<T>;",
            "template<class T>",
            "using PQrev = priority_queue<T, vector<T>, greater<T>>;",
            "",
            "template<class S, class T>",
            "istream &operator>>(istream &is, pair<S, T> &p) { return is >> p.first >> p.second; }",
            "",
            "template<class S, class T>",
            "ostream &operator<<(ostream &os, const pair<S, T> &p) { return os << '{' << p.first << \", \" << p.second << '}'; }",
            "",
            "template<class S, class T, class U>",
            "istream &operator>>(istream &is, tuple<S, T, U> &t) { return is >> get<0>(t) >> get<1>(t) >> get<2>(t); }",
            "",
            "template<class S, class T, class U>",
            "ostream &operator<<(ostream &os, const tuple<S, T, U> &t) {",
            "    return os << '{' << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << '}';",
            "}",
            "",
            "template<class T>",
            "istream &operator>>(istream &is, vector<T> &v) {",
            "    for (T &t: v) { is >> t; }",
            "    return is;",
            "}",
            "",
            "template<class T>",
            "ostream &operator<<(ostream &os, const vector<T> &v) {",
            "    os << '[';",
            "    rep(i, v.size()) os << v[i] << (i == int(v.size() - 1) ? \"\" : \", \");",
            "    return os << ']';",
            "}",
            "",
            "template<class T>",
            "ostream &operator<<(ostream &os, const deque<T> &v) {",
            "    os << '[';",
            "    rep(i, v.size()) os << v[i] << (i == int(v.size() - 1) ? \"\" : \", \");",
            "    return os << ']';",
            "}",
            "",
            "template<class T>",
            "ostream &operator<<(ostream &os, const set<T> &st) {",
            "    os << '{';",
            "    auto it = st.begin();",
            "    while (it != st.end()) {",
            "        os << (it == st.begin() ? \"\" : \", \") << *it;",
            "        it++;",
            "    }",
            "    return os << '}';",
            "}",
            "",
            "template<class T>",
            "ostream &operator<<(ostream &os, const multiset<T> &st) {",
            "    os << '{';",
            "    auto it = st.begin();",
            "    while (it != st.end()) {",
            "        os << (it == st.begin() ? \"\" : \", \") << *it;",
            "        it++;",
            "    }",
            "    return os << '}';",
            "}",
            "",
            "template<class T, class U>",
            "ostream &operator<<(ostream &os, const map<T, U> &mp) {",
            "    os << '{';",
            "    auto it = mp.begin();",
            "    while (it != mp.end()) {",
            "        os << (it == mp.begin() ? \"\" : \", \") << *it;",
            "        it++;",
            "    }",
            "    return os << '}';",
            "}",
            "",
            "template<class T>",
            "void vecout(const vector<T> &v, char div = '\\n') {",
            "    rep(i, v.size()) cout << v[i] << (i == int(v.size() - 1) ? '\\n' : div);",
            "}",
            "",
            "template<class T>",
            "bool constexpr chmin(T &a, T b) {",
            "    if (a > b) {",
            "        a = b;",
            "        return true;",
            "    }",
            "    return false;",
            "}",
            "",
            "template<class T>",
            "bool constexpr chmax(T &a, T b) {",
            "    if (a < b) {",
            "        a = b;",
            "        return true;",
            "    }",
            "    return false;",
            "}",
            "",
            "void scan() {}",
            "",
            "template<class Head, class... Tail>",
            "void scan(Head &head, Tail &... tail) {",
            "    cin >> head;",
            "    scan(tail...);",
            "}",
            "",
            "template<class T>",
            "void print(const T &t) { cout << t << '\\n'; }",
            "",
            "template<class Head, class... Tail>",
            "void print(const Head &head, const Tail &... tail) {",
            "    cout << head << ' ';",
            "    print(tail...);",
            "}",
            "",
            "template<class T>",
            "vector<T> &operator+=(vector<T> &v, T x) {",
            "    for (T &t: v) t += x;",
            "    return v;",
            "}",
            "",
            "template<class T>",
            "vector<T> &operator-=(vector<T> &v, T x) {",
            "    for (T &t: v) t -= x;",
            "    return v;",
            "}",
            "",
            "template<class T>",
            "vector<T> &operator*=(vector<T> &v, T x) {",
            "    for (T &t: v) t *= x;",
            "    return v;",
            "}",
            "",
            "template<class T>",
            "vector<T> &operator/=(vector<T> &v, T x) {",
            "    for (T &t: v) t /= x;",
            "    return v;",
            "}",
            "",
            "struct Init_io {",
            "    Init_io() {",
            "        ios::sync_with_stdio(false);",
            "        cin.tie(nullptr);",
            "        cout.tie(nullptr);",
            "        cout << boolalpha << fixed << setprecision(15);",
            "        cerr << boolalpha << fixed << setprecision(15);",
            "    }",
            "} init_io;",
            "",
            "const string yes[] = {\"no\", \"yes\"};",
            "const string Yes[] = {\"No\", \"Yes\"};",
            "const string YES[] = {\"NO\", \"YES\"};",
            "const int inf = 1001001001;",
            "const ll linf = 1001001001001001001;",
            "",
            "void rearrange(const vi &) {}",
            "",
            "template<class T, class... Tail>",
            "void rearrange(const vi &ord, vector<T> &head, Tail &...tail) {",
            "    assert(ord.size() == head.size());",
            "    vector<T> ori = head;",
            "    rep(i, ord.size()) head[i] = ori[ord[i]];",
            "    rearrange(ord, tail...);",
            "}",
            "",
            "template<class T, class... Tail>",
            "void sort_by(vector<T> &head, Tail &... tail) {",
            "    vi ord(head.size());",
            "    iota(all(ord), 0);",
            "    sort(all(ord), [&](int i, int j) { return head[i] < head[j]; });",
            "    rearrange(ord, head, tail...);",
            "}",
            "",
            "bool in_rect(int i, int j, int h, int w) {",
            "    return 0 <= i and i < h and 0 <= j and j < w;",
            "}",
            "",
            "template<class T>",
            "constexpr vector<T> pow_table(int n, T base) {",
            "    vector<T> res(n, 1);",
            "    rep(i, n - 1) res[i + 1] = res[i] * base;",
            "    return res;",
            "}",
            "",
            "template<class T, class S>",
            "vector<T> cumsum(const vector<S> &v, bool shift_one = true) {",
            "    int n = v.size();",
            "    vector<T> res;",
            "    if (shift_one) {",
            "        res.resize(n + 1);",
            "        rep(i, n) res[i + 1] = res[i] + v[i];",
            "    } else {",
            "        res.resize(n);",
            "        if (n) {",
            "            res[0] = v[0];",
            "            rep(i, 1, n) res[i] = res[i - 1] + v[i];",
            "        }",
            "    }",
            "    return res;",
            "}",
            "",
            "vvi graph(int n, int m, bool directed = false, int origin = 1) {",
            "    vvi G(n);",
            "    rep(_, m) {",
            "        INT(u, v);",
            "        u -= origin, v -= origin;",
            "        G[u].pb(v);",
            "        if (!directed) G[v].pb(u);",
            "    }",
            "    return G;",
            "}",
            "",
            "template<class T>",
            "vector<vector<pair<int, T>>> weighted_graph(int n, int m, bool directed = false, int origin = 1) {",
            "    vector<vector<pair<int, T>>> G(n);",
            "    rep(_, m) {",
            "        int u, v;",
            "        T w;",
            "        scan(u, v, w);",
            "        u -= origin, v -= origin;",
            "        G[u].eb(v, w);",
            "        if (!directed) G[v].eb(u, w);",
            "    }",
            "    return G;",
            "}",
            "",
			"int main(){",
			"   ",
			"}"
        ],
        "description": "yutoさんのテンプレート"
    },
	"runlength": {
        "prefix": "runlength",
        "body": [
            "vector<pair<char, int>> RunLength(const string& str) {",
            "    int n = (int)str.size();",
            "    vector<pair<char, int>> ret;",
            "    for (int l = 0; l < n;) {",
            "        int r = l + 1;",
            "        for (; r < n && str[l] == str[r]; r++) {};",
            "        ret.push_back({str[l], r - l});",
            "        l = r;",
            "    }",
            "    return ret;",
            "}",
        ],
        "description": "ランレングス圧縮"
    },
	"2DSegmentTree": {
        "prefix": "2DSegmentTree",
        "body": [
            "template <typename T, typename F>",
            "struct SegmentTree2D {",
            " private:",
            "  int id(int h, int w) { return h * 2 * W + w; }",
            "",
            " public:",
            "  int H, W;",
            "  vector<T> seg;",
            "  const F f;",
            "  const T I;",
            "",
            "  SegmentTree2D(int h, int w, F _f, const T& i) : f(_f), I(i) { init(h, w); }",
            "",
            "  void init(int h, int w) {",
            "    H = W = 1;",
            "    while (H < h) H <<= 1;",
            "    while (W < w) W <<= 1;",
            "    seg.assign(4 * H * W, I);",
            "  }",
            "",
            "  // build にのみ呼ぶ",
            "  void set(int h, int w, const T& x) { seg[id(h + H, w + W)] = x; }",
            "",
            "  void build() {",
            "    // w in [W, 2W)",
            "    for (int w = W; w < 2 * W; w++) {",
            "      for (int h = H - 1; h; h--) {",
            "        seg[id(h, w)] = f(seg[id(2 * h + 0, w)], seg[id(2 * h + 1, w)]);",
            "      }",
            "    }",
            "    // h in [0, 2H)",
            "    for (int h = 0; h < 2 * H; h++) {",
            "      for (int w = W - 1; w; w--) {",
            "        seg[id(h, w)] = f(seg[id(h, 2 * w + 0)], seg[id(h, 2 * w + 1)]);",
            "      }",
            "    }",
            "  }",
            "",
            "  T get(int h, int w) const { return seg[id(h + H, w + W)]; }",
            "  T operator()(int h, int w) const { return seg[id(h + H, w + W)]; }",
            "",
            "  void update(int h, int w, const T& x) {",
            "    h += H, w += W;",
            "    seg[id(h, w)] = x;",
            "    for (int i = h >> 1; i; i >>= 1) {",
            "      seg[id(i, w)] = f(seg[id(2 * i + 0, w)], seg[id(2 * i + 1, w)]);",
            "    }",
            "    for (; h; h >>= 1) {",
            "      for (int j = w >> 1; j; j >>= 1) {",
            "        seg[id(h, j)] = f(seg[id(h, 2 * j + 0)], seg[id(h, 2 * j + 1)]);",
            "      }",
            "    }",
            "  }",
            "",
            "  T _inner_query(int h, int w1, int w2) {",
            "    T res = I;",
            "    for (; w1 < w2; w1 >>= 1, w2 >>= 1) {",
            "      if (w1 & 1) res = f(res, seg[id(h, w1)]), w1++;",
            "      if (w2 & 1) --w2, res = f(res, seg[id(h, w2)]);",
            "    }",
            "    return res;",
            "  }",
            "",
            "  // [ (h1,w1), (h2,w2) ) 半開",
            "  T query(int h1, int w1, int h2, int w2) {",
            "    if (h1 >= h2 || w1 >= w2) return I;",
            "    T res = I;",
            "    h1 += H, h2 += H, w1 += W, w2 += W;",
            "    for (; h1 < h2; h1 >>= 1, h2 >>= 1) {",
            "      if (h1 & 1) res = f(res, _inner_query(h1, w1, w2)), h1++;",
            "      if (h2 & 1) --h2, res = f(res, _inner_query(h2, w1, w2));",
            "    }",
            "    return res;",
            "  }",
            "};",
        ],
        "description": "二次元セグメント木"
    },
	"2DCultivateSum": {
        "prefix": "2DCultivateSum",
        "body": [
            "// 二次元累積和",
            "template<typename T>",
            "struct CumulativeSum {",
            "    vector<vector<T>> Sum;",
            "    CumulativeSum(int H,int W,vector<vector<T>> vec) {",
            "        Sum.resize(H + 1,vector<T>(W + 1,0));",
            "        for(int i = 0;i < H;i++) {",
            "            for(int j = 0;j < W;j++) {",
            "                Sum.at(i + 1).at(j + 1) = Sum.at(i).at(j + 1) + Sum.at(i + 1).at(j) - Sum.at(i).at(j) + vec.at(i).at(j);",
            "            }",
            "        }",
            "    }",
            "    //クエリ[x1,x2)*[y1,y2)(0-indexed)の長方形区域の和",
            "    T query(int x1,int x2,int y1,int y2) {",
            "        return Sum.at(x2).at(y2) - Sum.at(x1).at(y2) - Sum.at(x2).at(y1) + Sum.at(x1).at(y1);",
            "    }",
            "};",
        ],
        "description": "二次元累積和"
    },
    "lpck": {
        "prefix": "lpck",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef long long ll;",
            "#define reps(i, a, n) for (ll i = (a); i < (ll)(n); ++i)",
            "#define rep(i, n) reps(i, 0, n)",
            "",
            "int main(){",
            "    ",
            "}",
        ],
        "description": ""
    },
    "GCD": {
        "prefix": "GCD",
        "body": [
            "ll gcd(ll a, ll b) {",
            "    if (b == 0) {",
            "        return a;",
            "    } else {",
            "        return gcd(b, a % b);",
            "    }",
            "}",
        ],
        "description": "最大公約数"
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "struct Node{",
            "    ll to;",
            "    ll cost;",
            "};",
            "vll dijkstra(const vector<vector<Node>>& G,ll startIndex){",
            "    vll dist(G.size(),LINF);",
            "    priority_queue<pll,vector<pll>,greater<pll>> que;",
            "    que.push(mp(0,startIndex));",
            "    while(!que.empty()){",
            "        ll v=que.top().second,c=que.top().first;",
            "        que.pop();",
            "        if(!chmin(dist[v],c)) continue;",
            "        for(const auto& N:G[v]){",
            "            if(dist[N.to]>dist[v]+N.cost) que.push(mp(dist[v]+N.cost,N.to));",
            "        }",
            "    }",
            "    return dist;",
            "}",
        ],
        "description": "ダイクストラ法"
    },
    "factorize": {
        "prefix": "factorize",
        "body": [
            "vector<pair<long long, long long>> prime_factorize(long long N) {",
            "    vector<pair<long long, long long> > res;",
            "    for (long long a = 2; a * a <= N; ++a) {",
            "        if (N % a != 0) continue;",
            "        long long ex = 0;",
            "        while (N % a == 0) {",
            "            ++ex;",
            "            N /= a;",
            "        }",
            "        res.push_back({a, ex});",
            "    }",
            "    if (N != 1) res.push_back({N, 1});",
            "    return res;",
            "}",
        ],
        "description": "素因数分解"
    },
    "enum_divisors": {
        "prefix": "enum_divisors",
        "body": [
            "vector<long long> enum_divisors(long long N) {",
            "    vector<long long> res;",
            "    for (long long i = 1; i * i <= N; ++i) {",
            "        if (N % i == 0) {",
            "            res.push_back(i);",
            "            if (N / i != i)",
            "                res.push_back(N / i);",
            "        }",
            "    }",
            "    sort(res.begin(), res.end());",
            "    return res;",
            "}",
        ],
        "description": "約数を昇順に列挙する"
    },
    "fps_opt": {
        "prefix": "fps_opt",
        "body": [
            "#define rep2(i, m, n) reps(i, m, n)",
            "#define rep(i, n) rep2(i, 0, n)",
            "#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)",
            "#define drep(i, n) drep2(i, n, 0)",
            "",
            "template<class T>",
            "struct FormalPowerSeries : vector<T> {",
            "  using vector<T>::vector;",
            "  using vector<T>::operator=;",
            "  using F = FormalPowerSeries;",
            "",
            "  F operator-() const {",
            "    F res(*this);",
            "    for (auto &e : res) e = -e;",
            "    return res;",
            "  }",
            "  F &operator*=(const T &g) {",
            "    for (auto &e : *this) e *= g;",
            "    return *this;",
            "  }",
            "  F &operator/=(const T &g) {",
            "    assert(g != T(0));",
            "    *this *= g.inv();",
            "    return *this;",
            "  }",
            "  F &operator+=(const F &g) {",
            "    int n = (*this).size(), m = g.size();",
            "    rep(i, min(n, m)) (*this)[i] += g[i];",
            "    return *this;",
            "  }",
            "  F &operator-=(const F &g) {",
            "    int n = (*this).size(), m = g.size();",
            "    rep(i, min(n, m)) (*this)[i] -= g[i];",
            "    return *this;",
            "  }",
            "  F &operator<<=(const int d) {",
            "    int n = (*this).size();",
            "    (*this).insert((*this).begin(), d, 0);",
            "    (*this).resize(n);",
            "    return *this;",
            "  }",
            "  F &operator>>=(const int d) {",
            "    int n = (*this).size();",
            "    (*this).erase((*this).begin(), (*this).begin() + min(n, d));",
            "    (*this).resize(n);",
            "    return *this;",
            "  }",
            "  F inv(int d = -1) const {",
            "    int n = (*this).size();",
            "    assert(n != 0 && (*this)[0] != 0);",
            "    if (d == -1) d = n;",
            "    assert(d > 0);",
            "    F res{(*this)[0].inv()};",
            "    while (res.size() < d) {",
            "      int m = size(res);",
            "      F f(begin(*this), begin(*this) + min(n, 2*m));",
            "      F r(res);",
            "      f.resize(2*m), internal::butterfly(f);",
            "      r.resize(2*m), internal::butterfly(r);",
            "      rep(i, 2*m) f[i] *= r[i];",
            "      internal::butterfly_inv(f);",
            "      f.erase(f.begin(), f.begin() + m);",
            "      f.resize(2*m), internal::butterfly(f);",
            "      rep(i, 2*m) f[i] *= r[i];",
            "      internal::butterfly_inv(f);",
            "      T iz = T(2*m).inv(); iz *= -iz;",
            "      rep(i, m) f[i] *= iz;",
            "      res.insert(res.end(), f.begin(), f.begin() + m);",
            "    }",
            "    return {res.begin(), res.begin() + d};",
            "  }",
            "",
            "  // // fast: FMT-friendly modulus only",
            "  // F &operator*=(const F &g) {",
            "  //   int n = (*this).size();",
            "  //   *this = convolution(*this, g);",
            "  //   (*this).resize(n);",
            "  //   return *this;",
            "  // }",
            "  // F &operator/=(const F &g) {",
            "  //   int n = (*this).size();",
            "  //   *this = convolution(*this, g.inv(n));",
            "  //   (*this).resize(n);",
            "  //   return *this;",
            "  // }",
            "",
            "  // // naive",
            "  // F &operator*=(const F &g) {",
            "  //   int n = (*this).size(), m = g.size();",
            "  //   drep(i, n) {",
            "  //     (*this)[i] *= g[0];",
            "  //     rep2(j, 1, min(i+1, m)) (*this)[i] += (*this)[i-j] * g[j];",
            "  //   }",
            "  //   return *this;",
            "  // }",
            "  // F &operator/=(const F &g) {",
            "  //   assert(g[0] != T(0));",
            "  //   T ig0 = g[0].inv();",
            "  //   int n = (*this).size(), m = g.size();",
            "  //   rep(i, n) {",
            "  //     rep2(j, 1, min(i+1, m)) (*this)[i] -= (*this)[i-j] * g[j];",
            "  //     (*this)[i] *= ig0;",
            "  //   }",
            "  //   return *this;",
            "  // }",
            "",
            "  // sparse",
            "  F &operator*=(vector<pair<int, T>> g) {",
            "    int n = (*this).size();",
            "    auto [d, c] = g.front();",
            "    if (d == 0) g.erase(g.begin());",
            "    else c = 0;",
            "    drep(i, n) {",
            "      (*this)[i] *= c;",
            "      for (auto &[j, b] : g) {",
            "        if (j > i) break;",
            "        (*this)[i] += (*this)[i-j] * b;",
            "      }",
            "    }",
            "    return *this;",
            "  }",
            "  F &operator/=(vector<pair<int, T>> g) {",
            "    int n = (*this).size();",
            "    auto [d, c] = g.front();",
            "    assert(d == 0 && c != T(0));",
            "    T ic = c.inv();",
            "    g.erase(g.begin());",
            "    rep(i, n) {",
            "      for (auto &[j, b] : g) {",
            "        if (j > i) break;",
            "        (*this)[i] -= (*this)[i-j] * b;",
            "      }",
            "      (*this)[i] *= ic;",
            "    }",
            "    return *this;",
            "  }",
            "",
            "  // multiply and divide (1 + cz^d)",
            "  void multiply(const int d, const T c) { ",
            "    int n = (*this).size();",
            "    if (c == T(1)) drep(i, n-d) (*this)[i+d] += (*this)[i];",
            "    else if (c == T(-1)) drep(i, n-d) (*this)[i+d] -= (*this)[i];",
            "    else drep(i, n-d) (*this)[i+d] += (*this)[i] * c;",
            "  }",
            "  void divide(const int d, const T c) {",
            "    int n = (*this).size();",
            "    if (c == T(1)) rep(i, n-d) (*this)[i+d] -= (*this)[i];",
            "    else if (c == T(-1)) rep(i, n-d) (*this)[i+d] += (*this)[i];",
            "    else rep(i, n-d) (*this)[i+d] -= (*this)[i] * c;",
            "  }",
            "",
            "  T eval(const T &a) const {",
            "    T x(1), res(0);",
            "    for (auto e : *this) res += e * x, x *= a;",
            "    return res;",
            "  }",
            "",
            "  F operator*(const T &g) const { return F(*this) *= g; }",
            "  F operator/(const T &g) const { return F(*this) /= g; }",
            "  F operator+(const F &g) const { return F(*this) += g; }",
            "  F operator-(const F &g) const { return F(*this) -= g; }",
            "  F operator<<(const int d) const { return F(*this) <<= d; }",
            "  F operator>>(const int d) const { return F(*this) >>= d; }",
            "  F operator*(const F &g) const { return F(*this) *= g; }",
            "  F operator/(const F &g) const { return F(*this) /= g; }",
            "  F operator*(vector<pair<int, T>> g) const { return F(*this) *= g; }",
            "  F operator/(vector<pair<int, T>> g) const { return F(*this) /= g; }",
            "};",
            "using mint = modint998244353;",
            "using fps = FormalPowerSeries<mint>;",
            "using sfps = vector<pair<int, mint>>;",
            "",
        ],
        "description": "optさんのFPSライブラリ"
    },
    "Geometry": {
        "prefix": "Geometry",
        "body": [
            "#include <ccomplex>",
            "#include <cmath>",
            "",
            "namespace geom{",
            "    using namespace std;",
            "    using D = long double;",
            "    using point = complex<D>;",
            "    const D EPS = 1e-7;",
            "    const D PI = acos(D(-1));    ",
            "",
            "    /**",
            "     * @brief 誤差を考慮した等号",
            "     */",
            "    inline bool equal(const D &a, const D &b) {",
            "        return fabs(a - b) < EPS;",
            "    }",
            "",
            "    /**",
            "     * @brief 単位ベクトル",
            "     */",
            "    point unitVec(const point &a) {",
            "        return a / abs(a);",
            "    }",
            "",
            "    /**",
            "     * @brief 法線ベクトル",
            "     */",
            "    point normalVec(const point &a) {",
            "        return a * point(0, -1);",
            "    }",
            "",
            "    /**",
            "     * @brief 内積",
            "     */",
            "    D dot(const point &a, const point &b) {",
            "        return (a.real() * b.real() + a.imag() * b.imag());",
            "    }",
            "",
            "    /**",
            "     * @brief 外積のz要素",
            "     */",
            "    D cross(const point &a, const point &b) {",
            "        return (a.real() * b.imag() - a.imag() * b.real());",
            "    }",
            "",
            "    /**",
            "     * @brief 反時計周りに theta 回転",
            "     */",
            "    point rotate(const point &p, const D &theta) {",
            "        return point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());",
            "    }",
            "",
            "    /**",
            "     * @brief 反時計回りに90度回転",
            "     */",
            "    point rotate_90(const point &p) {",
            "        return point(-p.imag(), p.real());",
            "    }",
            "",
            "    /**",
            "     * @brief 弧度法から度数法",
            "     */",
            "    D radian_to_degree(const D &d) {",
            "        return d * 180.0 / PI;",
            "    }",
            "",
            "    /**",
            "     * @brief 度数法から弧度法",
            "     */",
            "    D degree_to_radian(const D &d) {",
            "        return d * PI / 180.0;",
            "    }",
            "",
            "    /**",
            "     * @brief 直線",
            "     */",
            "    struct Line {",
            "        point a, b;",
            "        Line() = default;",
            "        /**",
            "         * @brief a, bを通る直線",
            "         */",
            "        Line(point a, point b) : a(a), b(b) {}",
            "        /**",
            "         * @brief Ax + By + C = 0 の直線",
            "         */",
            "        Line(D A, D B, D C) {",
            "            C = -C;",
            "            if (equal(A, 0)) {",
            "                a = point(0, C / B);",
            "                b = point(1, C / B);",
            "            } else if (equal(B, 0)) {",
            "                a = point(C / A, 0);",
            "                b = point(C / A, 1);",
            "            } else {",
            "                a = point(0, C / B);",
            "                b = point(C / A, 0);",
            "            }",
            "        }",
            "    };",
            "",
            "    /**",
            "     * @brief 線分",
            "     */",
            "    struct Segment : Line {",
            "        Segment() = default;",
            "        Segment(point a, point b) : Line(a, b) {}",
            "        /**",
            "         * @brief 線分の長さ",
            "         */",
            "        D dist() {",
            "            return abs(a - b);",
            "        }",
            "    };",
            "    ",
            "    /**",
            "     * @brief 円",
            "     */",
            "    struct Circle {",
            "        point p;",
            "        D r;",
            "        Circle() = default;",
            "        Circle(point p, D r) : p(p), r(r) {}",
            "    };",
            "    ",
            "    /**",
            "     * @brief 2直線が直行するか",
            "     */",
            "    bool orthogonal(const Line &a, const Line &b) {",
            "        return equal(dot(a.b - a.a, b.b - b.a), 0);",
            "    }",
            "",
            "    /**",
            "     * @brief 2直線が平行であるか",
            "     */",
            "    bool parallel(const Line &a, const Line &b) {",
            "        return equal(cross(a.b - a.a, b.b - b.a), 0);",
            "    }",
            "",
            "    /**",
            "     * @brief 点が直線上にあるかどうか",
            "     */",
            "    bool isPointOnLine(const point &a, const Line &l) {",
            "        return parallel(Line(a, l.a), Line(a, l.b));",
            "    }",
            "",
            "    /**",
            "     * @brief 点が線分上にあるかどうか",
            "     */",
            "    bool isPointOnSegment(const point &a, const Segment &l) {",
            "        return (abs(l.a - a) + abs(l.b - a) < abs(l.a - l.b) + EPS);",
            "    }",
            "",
            "    /**",
            "     * @brief 点と直線の距離",
            "     */",
            "    D distance_Line_Point(const Line &l, const point &p) {",
            "        return abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);",
            "    }",
            "",
            "    /**",
            "     * @brief 点と線分の距離",
            "     */",
            "    D distance_Segment_Point(const Segment &l, const point &p) {",
            "        if(dot(l.b - l.a, p - l.a) < EPS)",
            "            return abs(p - l.a);",
            "        if(dot(l.a - l.b, p - l.b) < EPS)",
            "            return abs(p - l.b);",
            "        return abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);",
            "    }",
            "",
            "    /**",
            "     * @brief 2直線の交点",
            "     */",
            "    point CrossPoint(const Line &s, const Line &t) {",
            "        D d1 = cross(s.b - s.a, t.b - t.a);",
            "        D d2 = cross(s.b - s.a, s.b - t.a);",
            "        if (equal(abs(d1), 0) && equal(abs(d2), 0)) return t.a;",
            "        return t.a + (t.b - t.a) * (d2 / d1);",
            "    }",
            "",
            "    const int COUNTER_CLOCKWISE = 1;",
            "    const int CLOCKWISE = -1;",
            "    const int ONLINE_BACK = 2;",
            "    const int ONLINE_FRONT = -2;",
            "    const int ON_SEGMENT = 0;",
            "    /**",
            "     * @brief 点p0, p1, p2 の位置関係",
            "     *",
            "     * @return int 1: 反時計回り, -1: 時計回り, 2: c, a, bの順で同一直線上, -2: a, b, cの順で同一直線上, 0: cが線分a, b上に存在",
            "     */",
            "    int ccw(point &p0, point &p1, point &p2)",
            "    {",
            "        point a = p1 - p0;",
            "        point b = p2 - p0;",
            "        if (cross(a, b) > EPS)",
            "            return COUNTER_CLOCKWISE;",
            "        if (cross(a, b) < -EPS)",
            "            return CLOCKWISE;",
            "        if (dot(a, b) < 0)",
            "            return ONLINE_BACK;",
            "        if (norm(a) < norm(b))",
            "            return ONLINE_FRONT;",
            "        return ON_SEGMENT;",
            "    }",
            "",
            "    /**",
            "     * @brief 線分s, tが交差するか",
            "     * @param bound 端点を含むか",
            "     */",
            "    bool intersect(Segment &s, Segment &t, bool bound = true) {",
            "        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) < bound && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) < bound;",
            "    }",
            "",
            "    /**",
            "     * @brief 2線分の距離",
            "     */",
            "    D distance_Segment_Segment(Segment &s, Segment &t) {",
            "        if (intersect(s, t)) return D(0);",
            "        D ans = distance_Segment_Point(s, t.a);",
            "        ans = min(ans, distance_Segment_Point(s, t.b));",
            "        ans = min(ans, distance_Segment_Point(t, s.a));",
            "        ans = min(ans, distance_Segment_Point(t, s.b));",
            "        return ans;",
            "    }",
            "",
            "    /**",
            "     * @brief 垂線の足",
            "     */",
            "    point projection(const Line &l, const point &p) {",
            "        D t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);",
            "        return l.a + (l.a - l.b) * t;",
            "    }",
            "    point projection(const Segment &l, const point &p) {",
            "        D t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);",
            "        return l.a + (l.a - l.b) * t;",
            "    }",
            "",
            "    /**",
            "     * @brief lを軸としてpを対称移動させた点",
            "     */",
            "    point reflection(const Line &l, const point &p) {",
            "        return p + (projection(l, p) - p) * D(2);",
            "    }",
            "",
            "    /**",
            "     * @brief 2円の関係",
            "     * @return int 共通接線の個数, 0: 内包, 1: 内接, 2: 2点で交わる, 3: 外接, 4: 交点を持たない",
            "     */",
            "    int intersect(const Circle &a, const Circle &b) {",
            "        D d = abs(a.p - b.p);",
            "        if (d > a.r + b.r + EPS) return 4;",
            "        if (equal(d, a.r + b.r)) return 3;",
            "        if (equal(d, abs(a.r - b.r))) return 1;",
            "        if (d < abs(a.r - b.r) - EPS) return 0;",
            "        return 2;",
            "    }",
            "",
            "    /**",
            "     * @brief 2円の交点",
            "     */",
            "    vector<point> CrossPoint(const Circle &a, const Circle &b) {",
            "        vector<point> res;",
            "        int mode = intersect(a, b);",
            "        D d = abs(a.p - b.p);",
            "        if (mode == 4) return res;",
            "        if (mode == 0) return res;",
            "        if (mode == 3) {",
            "            D t = a.r / (a.r + b.r);",
            "            res.emplace_back(a.p + (b.p - a.p) * t);",
            "            return res;",
            "        }",
            "        if (mode == 1) {",
            "            if (b.r < a.r - EPS) {",
            "                res.emplace_back(a.p + (b.p - a.p) * (a.r / d));",
            "            } else {",
            "                res.emplace_back(b.p + (a.p - b.p) * (b.r / d));",
            "            }",
            "            return res;",
            "        }",
            "        D rc1 = (a.r * a.r + d * d - b.r * b.r) / (2 * d);",
            "        D rs1 = sqrt(a.r * a.r - rc1 * rc1);",
            "        if (a.r - abs(rc1) < EPS) rs1 = 0;",
            "        point e12 = (b.p - a.p) / abs(b.p - a.p);",
            "        res.emplace_back(a.p + rc1 * e12 + rs1 * e12 * point(0, 1));",
            "        res.emplace_back(a.p + rc1 * e12 + rs1 * e12 * point(0, -1));",
            "        return res;",
            "    }",
            "",
            "    /**",
            "     * @brief 点が円の内部(円周上含む)に含まれるか",
            "     */",
            "    bool inCircle(const Circle &C, const point &p) {",
            "        D d = abs(C.p - p);",
            "        return (equal(d, C.r) || d < C.r - EPS);",
            "    }",
            "",
            "    /**",
            "     * @brief 直線と円の交点 ",
            "     */",
            "    vector<point> CrossPoint(const Line &l, const Circle &c) {",
            "        vector<point> res;",
            "        D d = distance_Line_Point(l, c.p);",
            "        if (d > c.r + EPS) return res;",
            "        point h = projection(l, c.p);",
            "        if (equal(d, c.r)) {",
            "            res.emplace_back(h);",
            "            return res;",
            "        }",
            "        point e = unitVec(l.b - l.a);",
            "        D ph = sqrt(c.r * c.r - d * d);",
            "        res.emplace_back(h - e * ph);",
            "        res.emplace_back(h + e * ph);",
            "        return res;",
            "    }",
            "",
            "    /**",
            "     * @brief 点pを通って円cに接する接線の接点",
            "     */",
            "    vector<point> tangentPoint(const point &p, const Circle &c) {",
            "        return CrossPoint(c, Circle(p, sqrt(norm(c.p - p) - c.r * c.r)));",
            "    }",
            "",
            "    /**",
            "     * @brief 2円の共通接線 ",
            "     */",
            "    vector<Line> commonTangentLine(const Circle &a, const Circle &b) {",
            "        vector<Line> res;",
            "        D g = abs(a.p - b.p);",
            "        if (equal(g, 0)) return res;",
            "        point u = unitVec(b.p - a.p);",
            "        point v = rotate(u, PI / 2);",
            "        for (auto &s : {-1, 1}) {",
            "            D h = (a.r + b.r * s) / g;",
            "            if (equal(h * h, 1)) {",
            "                res.emplace_back(Line(a.p + (h > 0 ? u : -u) * a.r, a.p + (h > 0 ? u : -u) * a.r + v));",
            "            } else if (1 - h * h > 0) {",
            "                point U = u * h, V = v * sqrt(1 - h * h);",
            "                res.emplace_back(Line(a.p + (U + V) * a.r, b.p - (U + V) * (b.r * s)));",
            "                res.emplace_back(Line(a.p + (U - V) * a.r, b.p - (U - V) * (b.r * s)));",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    /**",
            "     * @brief 内接円",
            "     */",
            "    Circle Inscribed_Circle(point &a, point &b, point &c) {",
            "        D A = abs(b - c), B = abs(a - c), C = abs(a - b);",
            "        point p(A * real(a) + B * real(b) + C * real(c), A * imag(a) + B * imag(b) + C * imag(c));",
            "        p /= (A + B + C);",
            "        D r = distance_Line_Point(Line(a, b), p);",
            "        return Circle(p, r);",
            "    }",
            "",
            "    /**",
            "     * @brief 3点を通る円 (3角形の外接円)",
            "     */",
            "    Circle Circumscribed_Circle(point &a, point &b, point &c) {",
            "        Line s((a + b) / D(2), (a + b) / D(2) + rotate_90(b - a));",
            "        Line t((b + c) / D(2), (b + c) / D(2) + rotate_90(c - b));",
            "        point v = CrossPoint(s, t);",
            "        return Circle(v, abs(v - a));",
            "    }",
            "",
            "    using Polygon = vector<point>;",
            "",
            "    /**",
            "     * @brief 面積",
            "     */",
            "    D area(const Polygon &p) {",
            "        D res = 0;",
            "        int n = p.size();",
            "        for (int i = 0; i < n - 1; i++) {",
            "            res += cross(p[i], p[i + 1]);",
            "        }",
            "        res += cross(p[n - 1], p[0]);",
            "        return res / D(2);",
            "    }",
            "    D area(const Circle &c) {",
            "        return PI * c.r * c.r;",
            "    }",
            "",
            "    /**",
            "     * @brief 多角形が凸かどうか",
            "     */",
            "    bool convex(Polygon &p) {",
            "        int n = p.size();",
            "        int now, pre, nxt;",
            "        for (int i = 0; i < n; i++) {",
            "            pre = (i - 1 + n) % n;",
            "            nxt = (i + 1) % n;",
            "            now = i;",
            "            if (ccw(p[pre], p[now], p[nxt]) == -1) {",
            "                return false;",
            "            }",
            "        }",
            "        return true;",
            "    }",
            "",
            "    /**",
            "     * @brief 凸包",
            "     * @param mode 1直線上の3点を含めるか",
            "     */",
            "    Polygon ConvexHull(vector<point> &p, bool mode = false) {",
            "        int n = p.size(), k = 0;",
            "        int u = (mode ? -1 : 1);",
            "        sort(p.begin(), p.end(), [](const point &a, const point &b) {",
            "            return (a.real() != b.real() ? a.real() < b.real() : a.imag () < b.imag());",
            "        });",
            "        vector<point> ch(2 * n);",
            "        for (int i = 0; i < n; ch[k++] = p[i++]) {",
            "            while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < u * EPS) {",
            "                k--;",
            "            }",
            "        }",
            "        for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {",
            "            while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < u * EPS) {",
            "                k--;",
            "            }",
            "        }",
            "        ch.resize(k - 1);",
            "        return ch;",
            "    }",
            "",
            "    const int OUT = 0;",
            "    const int ON = 1;",
            "    const int IN = 2;",
            "    /**",
            "     * @brief 点が多角形に含まれるか",
            "     * @return int 0: 含まれない, 1: 辺上に存在, 2: 含まれる",
            "     */",
            "    int contain(const Polygon &g, point &p) {",
            "        bool in = false;",
            "        int n = g.size();",
            "        for (int i = 0; i < n; i++) {",
            "            point a = g[i] - p, b = g[(i + 1) % n] - p;",
            "            if (a.imag() > b.imag()) swap(a, b);",
            "            if (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;",
            "            if (equal(cross(a, b), 0) && dot(a, b) <= 0) return ON;",
            "        }",
            "        return (in ? IN : OUT);",
            "    }",
            "",
            "    /**",
            "     * @brief 多角形p を直線l で切断した左側の頂点集合",
            "     */",
            "    vector<point> convexCut(Polygon &p, Line &l) {",
            "        vector<point> res;",
            "        int n = p.size();",
            "        for (int i = 0; i < n; i++) {",
            "            point now = p[i];",
            "            point nxt = p[(i + 1) % n];",
            "            if (ccw(l.a, l.b, now) != CLOCKWISE) res.emplace_back(now);",
            "            if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {",
            "                res.emplace_back(CrossPoint(Line(now, nxt), l));",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    /**",
            "     * @brief 凸多角形の直径",
            "     */",
            "    D convex_Diameter(Polygon &g) {",
            "        int n = g.size();",
            "        int is = 0, js = 0;",
            "        for (int i = 1; i < n; i++) {",
            "            if (g[i].imag() > g[is].imag()) is = i;",
            "            if (g[i].imag() < g[js].imag()) js = i;",
            "        }",
            "        D maxdis = norm(g[is] - g[js]);",
            "        int maxi, maxj, i, j;",
            "        i = maxi = is;",
            "        j = maxj = js;",
            "        do {",
            "            if (cross(g[(i + 1) % n] - g[i], g[(j + 1) % n] - g[j]) >= 0) {",
            "                j = (j + 1) % n;",
            "            } else {",
            "                i = (i + 1) % n;",
            "            }",
            "            if (norm(g[i] - g[j]) > maxdis) {",
            "                maxdis = norm(g[i] - g[j]);",
            "                maxi = i;",
            "                maxj = j;",
            "            }",
            "        } while (i != is || j != js);",
            "        return sqrt(maxdis);",
            "    }",
            "",
            "    /**",
            "     * @brief 最近点対の距離",
            "     */",
            "    D closest_pair(vector<point> &ps) {",
            "        if (ps.size() <= 1) throw(0);",
            "        sort(ps.begin(), ps.end(), [](const point &a, const point &b) {",
            "            return (a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag());",
            "        });",
            "        auto comp_y = [&](const point &a, const point &b) {",
            "            return a.imag() < b.imag();",
            "        };",
            "        vector<point> beet(ps.size());",
            "        const D INF = 1e18;",
            "        function<D(int, int)> rec = [&](int l, int r) {",
            "            if (r - l <= 1) return INF;",
            "            int mid = (l + r) >> 1;",
            "            auto x = ps[mid].real();",
            "            auto ret = min(rec(l, mid), rec(mid, r));",
            "            inplace_merge(ps.begin() + l, ps.begin() + mid, ps.begin() + r, comp_y);",
            "            int ptr = 0;",
            "            for (int i = l; i < r; i++) {",
            "                if (abs(ps[i].real() - x) >= ret) continue;",
            "                for (int j = 0; j < ptr; j++) {",
            "                    auto luz = ps[i] - beet[ptr - j - 1];",
            "                    if (luz.imag() >= ret) break;",
            "                    ret = min(ret, abs(luz));",
            "                }",
            "                beet[ptr++] = ps[i];",
            "            }",
            "            return ret;",
            "        };",
            "        return rec(0, (int)ps.size());",
            "    }",
            "",
            "    /**",
            "     * @brief 偏角ソートの比較関数 (-π ≤ arg ≤ π)",
            "     */",
            "    bool Declination_comp(point &a, point &b) {",
            "        return arg(a) < arg(b);",
            "    }",
            "",
            "    /**",
            "     * @brief 点のソートの比較関数",
            "     */",
            "    bool Point_comp(point &a, point &b) {",
            "        return (a.real() != b.real() ? a.imag() < b.imag() : a.real() < b.real());",
            "    }",
            "",
            "    /**",
            "     * @brief 直線の重複を取り除く",
            "     */",
            "    vector<Line> merge(vector<Line> L) {",
            "        auto comp = [](Line &a, Line &b) {",
            "            point l = a.b - a.a;",
            "            point m = b.b - b.a;",
            "            if (l.real() < 0)",
            "                l *= -1;",
            "            if (m.real() < 0)",
            "                m *= -1;",
            "            if (equal(a.a.real(), a.b.real()) && l.imag() > -EPS)",
            "                l *= -1;",
            "            if (equal(b.a.real(), b.b.real()) && m.imag() > -EPS)",
            "                m *= -1;",
            "            return Declination_comp(l, m);",
            "        };",
            "        vector<Line> ans;",
            "        vector<bool> ok(L.size(), true);",
            "        sort(L.begin(), L.end(), comp);",
            "        for (int i = 0; i < L.size(); i++) {",
            "            if (!ok[i]) continue;",
            "            ans.emplace_back(L[i]);",
            "            for (int j = i + 1; j < L.size(); j++) {",
            "                point l = L[i].b - L[i].a;",
            "                point m = L[j].b - L[j].a;",
            "                if (l.real() < 0)",
            "                    l *= -1;",
            "                if (m.real() < 0)",
            "                    m *= -1;",
            "                if (equal(L[i].a.real(), L[i].b.real()) && l.imag() > -EPS)",
            "                    l *= -1;",
            "                if (equal(L[j].a.real(), L[j].b.real()) && m.imag() > -EPS)",
            "                    m *= -1;",
            "                if (!equal(arg(l), arg(m)))",
            "                    break;",
            "                if (!ok[j]) continue;",
            "                if (parallel(L[i], L[j]) && isPointOnLine(L[i].a, L[j])) {",
            "                    ok[j] = false;",
            "                }",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    inline ostream &operator<<(ostream &os, const point &p) {",
            "        os << '(' << p.real() << ',' << p.imag() << ')';",
            "        return os;",
            "    }",
            "",
            "    inline ostream &operator<<(ostream &os, const Line &l) {",
            "        os << l.a << \" to \" << l.b;",
            "        return os;",
            "    }",
            "",
            "    inline ostream &operator<<(ostream &os, const Segment &l) {",
            "        os << Line(l);",
            "        return os;",
            "    }",
            "",
            "    inline ostream &operator<<(ostream &os, const Circle &c) {",
            "        os << \"center:\" << c.p << \" radius:\" << c.r; ",
            "        return os;",
            "    }",
            "",
            "    inline ostream &operator<<(ostream &os, const Polygon &p) {",
            "        int n = p.size();",
            "        for (int i = 0; i < n; i++) {",
            "            os << p[i] << ',';",
            "        }",
            "        return os;",
            "    }",
            "}",
        ],
        "description": "幾何ライブラリ"
    },
    "RollingHash": {
        "prefix": "RollingHash",
        "body": [
            "template< unsigned mod >",
            "struct RollingHash {",
            "  vector< unsigned > hashed, power;",
            "",
            "  inline unsigned mul(unsigned a, unsigned b) const {",
            "    unsigned long long x = (unsigned long long) a * b;",
            "    unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;",
            "    asm(\"divl %4; \\n\\t\" : \"=a\" (d), \"=d\" (m) : \"d\" (xh), \"a\" (xl), \"r\" (mod));",
            "    return m;",
            "  }",
            "",
            "  RollingHash(const string &s, unsigned base = 10007) {",
            "    int sz = (int) s.size();",
            "    hashed.assign(sz + 1, 0);",
            "    power.assign(sz + 1, 0);",
            "    power[0] = 1;",
            "    for(int i = 0; i < sz; i++) {",
            "      power[i + 1] = mul(power[i], base);",
            "      hashed[i + 1] = mul(hashed[i], base) + s[i];",
            "      if(hashed[i + 1] >= mod) hashed[i + 1] -= mod;",
            "    }",
            "  }",
            "",
            "  unsigned get(int l, int r) const {",
            "    unsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);",
            "    if(ret >= mod) ret -= mod;",
            "    return ret;",
            "  }",
            "",
            "  unsigned connect(unsigned h1, int h2, int h2len) const {",
            "    unsigned ret = mul(h1, power[h2len]) + h2;",
            "    if(ret >= mod) ret -= mod;",
            "    return ret;",
            "  }",
            "",
            "  int LCP(const RollingHash< mod > &b, int l1, int r1, int l2, int r2) {",
            "    int len = min(r1 - l1, r2 - l2);",
            "    int low = -1, high = len + 1;",
            "    while(high - low > 1) {",
            "      int mid = (low + high) / 2;",
            "      if(get(l1, l1 + mid) == b.get(l2, l2 + mid)) low = mid;",
            "      else high = mid;",
            "    }",
            "    return (low);",
            "  }",
            "};",
            "",
            "using RH = RollingHash< 1000000007 >;",
            "",
        ],
        "description": "Luzhiledさんのローリングハッシュ"
    },
    "Compress-zaatsu": {
        "prefix": "Compress-zaatsu",
        "body": [
            "template< typename T >",
            "struct Compress {",
            "  vector< T > xs;",
            "",
            "  Compress() = default;",
            "",
            "  Compress(const vector< T > &vs) {",
            "    add(vs);",
            "  }",
            "",
            "  Compress(const initializer_list< vector< T > > &vs) {",
            "    for(auto &p : vs) add(p);",
            "  }",
            "",
            "  void add(const vector< T > &vs) {",
            "    copy(begin(vs), end(vs), back_inserter(xs));",
            "  }",
            "",
            "  void add(const T &x) {",
            "    xs.emplace_back(x);",
            "  }",
            "",
            "  void build() {",
            "    sort(begin(xs), end(xs));",
            "    xs.erase(unique(begin(xs), end(xs)), end(xs));",
            "  }",
            "",
            "  vector< int > get(const vector< T > &vs) const {",
            "    vector< int > ret;",
            "    transform(begin(vs), end(vs), back_inserter(ret), [&](const T &x) {",
            "      return lower_bound(begin(xs), end(xs), x) - begin(xs);",
            "    });",
            "    return ret;",
            "  }",
            "",
            "  int get(const T &x) const {",
            "    return lower_bound(begin(xs), end(xs), x) - begin(xs);",
            "  }",
            "",
            "  const T &operator[](int k) const {",
            "    return xs[k];",
            "  }",
            "};",
        ],
        "description": "Luzhiledさんの座標圧縮"
    },
    "nekoset_mex": {
        "prefix": "nekoset_mex",
        "body": [
            "struct nekoset {",
            "",
            "  std::set<std::pair<int, int>> s;",
            "  map<int, int> m;",
            "",
            "  nekoset() {",
            "    s.emplace(INT_MIN, INT_MIN);",
            "    s.emplace(INT_MAX, INT_MAX);",
            "  }",
            "",
            "  bool contains(int x) const {",
            "    auto it = std::prev(s.lower_bound(std::make_pair(x+1, x+1)));",
            "    auto [l, u] = *it;",
            "    return l <= x && x <= u;",
            "  }",
            "",
            "  bool insert(int x) {",
            "   m[x]++;",
            "    auto nit = s.lower_bound(std::make_pair(x+1, x+1));",
            "    auto it = std::prev(nit);",
            "    auto [l, u] = *it;",
            "    auto [nl, nu] = *nit;",
            "    if (l <= x && x <= u) return false;",
            "    if (u == x-1) {",
            "      if (nl == x+1) {",
            "        s.erase(it);",
            "        s.erase(nit);",
            "        s.emplace(l, nu);",
            "      } else {",
            "        s.erase(it);",
            "        s.emplace(l, x);",
            "      }",
            "    } else {",
            "      if (nl == x+1) {",
            "        s.erase(nit);",
            "        s.emplace(x, nu);",
            "      } else {",
            "        s.emplace(x, x);",
            "      }",
            "    }",
            "    return true;",
            "  }",
            "",
            "  bool erase(int x){",
            "   auto it = std::prev(s.lower_bound(std::make_pair(x+1,x-1)));",
            "   auto [l,u] = *it;",
            "    if (!(l <= x && x <= u)) return false;",
            "   m[x]--;",
            "   if(m[x]==0){",
            "       s.erase(it);",
            "       if(x != l){",
            "           s.emplace(l,x-1);",
            "       }",
            "       if(x != u){",
            "           s.emplace(x+1,u);",
            "       }",
            "   }",
            "   return true;",
            "  }",
            "",
            "  bool change(int a,int b){",
            "   if(!contains(a)) return false;",
            "   erase(a);",
            "   insert(b);",
            "   return true;",
            "  }",
            "  int mex(int x = 0) const {",
            "    auto [l, u] = *std::prev(s.lower_bound(std::make_pair(x+1, x+1)));",
            "    if (l <= x && x <= u) {",
            "      return u+1;",
            "    } else {",
            "      return x;",
            "    }",
            "  }",
            "};",
        ],
        "description": "mexを求めるデータ構造"
    },
    "Mo": {
        "prefix": "Mo",
        "body": [
            "struct Mo {",
            "  int n;",
            "  vector< pair< int, int > > lr;",
            "",
            "  explicit Mo(int n) : n(n) {}",
            "",
            "  void add(int l, int r) { /* [l, r) */",
            "    lr.emplace_back(l, r);",
            "  }",
            "",
            "  template< typename AL, typename AR, typename EL, typename ER, typename O >",
            "  void build(const AL &add_left, const AR &add_right, const EL &erase_left, const ER &erase_right, const O &out) {",
            "    int q = (int) lr.size();",
            "    int bs = n / min< int >(n, sqrt(q));",
            "    vector< int > ord(q);",
            "    iota(begin(ord), end(ord), 0);",
            "    sort(begin(ord), end(ord), [&](int a, int b) {",
            "      int ablock = lr[a].first / bs, bblock = lr[b].first / bs;",
            "      if(ablock != bblock) return ablock < bblock;",
            "      return (ablock & 1) ? lr[a].second > lr[b].second : lr[a].second < lr[b].second;",
            "    });",
            "    int l = 0, r = 0;",
            "    for(auto idx : ord) {",
            "      while(l > lr[idx].first) add_left(--l);",
            "      while(r < lr[idx].second) add_right(r++);",
            "      while(l < lr[idx].first) erase_left(l++);",
            "      while(r > lr[idx].second) erase_right(--r);",
            "      out(idx);",
            "    }",
            "  }",
            "",
            "  template< typename A, typename E, typename O >",
            "  void build(const A &add, const E &erase, const O &out) {",
            "    build(add, add, erase, erase, out);",
            "  }",
            "};",
        ],
        "description": ""
    },
    "Sousya": {
        "prefix": "Sousya",
        "body": [
            "//操車場アルゴリズム（中置記法->逆ポーランド記法）",
            "string Sousya(string S){",
            "   string res = \"\";",
            "   stack<char> s;",
            "   for(auto& c:S){",
            "       if(c=='(')s.push(c);",
            "       else if(c==')'){",
            "           while(s.top()!='('){",
            "               res.pb(s.top());s.pop();",
            "           }",
            "           s.pop();",
            "       }else if(c=='+'||c=='-'){",
            "           s.push(c);",
            "       }else{",
            "           res.pb(c);",
            "       }",
            "   }",
            "   while(!s.empty()){",
            "       res.pb(s.top());s.pop();",
            "   }",
            "   return res;",
            "}",
        ],
        "description": ""
    },
        "COM": {
        "prefix": "COM",
        "body": [
            "// nCk mod p を求める mintの定義を先にする",
            "class COM{",
            "public:",
            "    vector<mint> fac;",
            "    vector<mint> finv;",
            "    vector<mint> inv;",
            "",
            "    COM(int _n=510000):fac(_n),finv(_n),inv(_n){",
            "        const int MOD = mint::mod();",
            "        fac[0] = fac[1] = 1;",
            "        finv[0] = finv[1] = 1;",
            "        inv[1] = 1;",
            "        for (int i = 2; i < _n; i++){",
            "            fac[i] = fac[i - 1] * i;",
            "            inv[i] = MOD - inv[MOD%i] * (MOD / i);",
            "            finv[i] = finv[i - 1] * inv[i];",
            "        }",
            "    }",
            "",
            "    // 二項係数計算",
            "    mint calc(int n, int k){",
            "        if (n < k) return 0;",
            "        if (n < 0 || k < 0) return 0;",
            "        return fac[n] * finv[k] * finv[n - k];",
            "    }",
            "};",
        ],
        "description": ""
    },
}
